<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>After Effects Automation</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <h1>After Effects Automation</h1>
                <p class="subtitle">Automate template population with intelligent content matching</p>
            </div>
            <div class="header-actions">
                <a href="/projects-page" class="settings-link">üìÅ Projects</a>
                <a href="/settings-page" class="settings-link">‚öôÔ∏è Settings</a>
            </div>
        </header>

        <!-- Upload Section -->
        <section class="card upload-section">
            <h2>1. Upload Files</h2>
            <div class="upload-grid">
                <div class="upload-box" id="psdDropZone">
                    <div class="upload-icon">üìÑ</div>
                    <h3>PSD File</h3>
                    <p>Drag & drop or click to select</p>
                    <input type="file" id="psdInput" accept=".psd" hidden>
                    <div class="file-info" id="psdInfo"></div>
                </div>
                <div class="upload-box" id="aepxDropZone">
                    <div class="upload-icon">üé¨</div>
                    <h3>AEPX/AEP Template</h3>
                    <p>Drag & drop or click to select</p>
                    <input type="file" id="aepxInput" accept=".aepx,.aep" hidden>
                    <div class="file-info" id="aepxInfo"></div>
                </div>
            </div>
            <button id="uploadBtn" class="btn btn-primary" disabled>Upload & Analyze</button>
            <div class="status-message" id="uploadStatus"></div>
        </section>

        <!-- File Info Section -->
        <section class="card info-section" id="infoSection" style="display: none;">
            <h2>File Information</h2>
            <div class="info-grid">
                <div class="info-card">
                    <h3>PSD Details</h3>
                    <div id="psdDetails"></div>
                </div>
                <div class="info-card">
                    <h3>Template Details</h3>
                    <div id="aepxDetails"></div>
                </div>
                <div class="info-card">
                    <h3>Font Check</h3>
                    <div id="fontDetails"></div>
                </div>
            </div>
            <button id="checkFontsBtn" class="btn btn-primary" style="display: none;">Check Fonts</button>
        </section>

        <!-- Font Check Section -->
        <section class="card font-section" id="fontSection" style="display: none;">
            <h2>1.5. Font Check</h2>
            <p class="section-description">Verify that required fonts are available</p>
            <div class="font-status" id="fontStatus"></div>
            <div id="fontList"></div>
            <div class="font-actions" id="fontActions" style="display: none;">
                <div class="upload-box-small">
                    <p>Upload missing fonts (TTF, OTF, WOFF)</p>
                    <input type="file" id="fontInput" accept=".ttf,.otf,.woff,.woff2" multiple hidden>
                    <button class="btn btn-primary" onclick="document.getElementById('fontInput').click()">
                        Choose Font Files
                    </button>
                </div>
                <button id="skipFontsBtn" class="btn btn-secondary">Continue Without Fonts</button>
            </div>
            <div class="status-message" id="fontUploadStatus"></div>
            <button id="matchBtn" class="btn btn-primary" style="display: none;">Match Content</button>
        </section>

        <!-- Mappings Section -->
        <section class="card mappings-section" id="mappingsSection" style="display: none;">
            <h2>2. Content Mappings</h2>
            <p class="section-description">Click a PSD layer, then click an AEPX placeholder to create a mapping</p>

            <div class="mapping-controls">
                <button id="loadPreviewsBtn" class="btn btn-primary">Load Visual Previews</button>
                <button id="resetMappingsBtn" class="btn btn-secondary">Reset to Auto-Match</button>
                <button id="clearSelectionBtn" class="btn btn-secondary" style="display: none;">Clear Selection</button>
            </div>

            <div class="status-message" id="mappingLoadStatus"></div>

            <!-- Visual Mapping Interface -->
            <div class="visual-mapping-container" id="visualMappingContainer" style="display: none;">
                <div class="mapping-panel">
                    <div class="panel-header">
                        <h3>PSD Layers</h3>
                        <span class="panel-subtitle">Click to select</span>
                    </div>
                    <div class="preview-grid" id="psdLayersGrid"></div>
                </div>

                <div class="mapping-center">
                    <div class="mapping-arrow">‚Üí</div>
                    <div class="current-mappings-list" id="currentMappingsList">
                        <h4>Current Mappings</h4>
                        <div id="mappingsList"></div>
                    </div>
                </div>

                <div class="mapping-panel">
                    <div class="panel-header">
                        <h3>AEPX Placeholders</h3>
                        <span class="panel-subtitle">Click to map to selected layer</span>
                    </div>
                    <div class="preview-grid" id="aepxPlaceholdersGrid"></div>
                </div>
            </div>

            <div class="mapping-stats" id="mappingStats"></div>
        </section>

        <!-- Conflicts Section -->
        <section class="card conflicts-section" id="conflictsSection" style="display: none;">
            <h2>3. Conflicts & Warnings</h2>
            <div class="conflict-summary" id="conflictSummary"></div>
            <div id="conflictsList"></div>
        </section>

        <!-- Preview Section -->
        <section class="card preview-section" id="previewSection" style="display: none;">
            <h2>4. Preview Video</h2>
            <p class="section-description">Generate a preview of your populated template</p>

            <div id="previewControls">
                <button id="generatePreviewBtn" class="btn btn-primary btn-large">Generate Preview</button>
                <button id="skipPreviewBtn" class="btn btn-secondary" style="margin-left: 10px;">Skip Preview</button>
            </div>

            <div class="status-message" id="previewStatus"></div>

            <div id="previewPlayer" style="display: none;">
                <div class="video-container">
                    <video id="previewVideo" controls style="width: 100%; max-width: 800px; border-radius: 10px; box-shadow: var(--shadow-lg);">
                        <source id="previewSource" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                </div>
                <div class="preview-info" id="previewInfo" style="margin-top: 15px; text-align: center;"></div>
                <div style="text-align: center; margin-top: 20px;">
                    <button id="proceedToGenerateBtn" class="btn btn-success btn-large">Looks Good! Generate Full Script</button>
                </div>
            </div>
        </section>

        <!-- Generate Section -->
        <section class="card generate-section" id="generateSection" style="display: none;">
            <h2>5. Generate Script</h2>
            <p class="section-description">Create the ExtendScript file for After Effects</p>
            <button id="generateBtn" class="btn btn-primary btn-large">Generate ExtendScript</button>
            <div class="status-message" id="generateStatus"></div>
            <div id="downloadSection" style="display: none;">
                <a id="downloadLink" class="btn btn-success btn-large" download>Download Script</a>
                <div class="instructions">
                    <h3>Next Steps:</h3>
                    <ol>
                        <li>Open After Effects</li>
                        <li>Open your template file</li>
                        <li>Run: File ‚Üí Scripts ‚Üí Run Script File</li>
                        <li>Select the downloaded .jsx file</li>
                    </ol>
                </div>
            </div>
        </section>

        <!-- Plainly Validation Section -->
        <section class="card validation-section" id="validationSection" style="display: none;">
            <h2>6. Plainly Validation</h2>
            <p class="section-description">Validate your template for Plainly compatibility before deployment</p>

            <div class="validation-controls">
                <button id="validatePlainlyBtn" class="btn btn-primary btn-large">üîç Validate for Plainly</button>
                <button id="skipValidationBtn" class="btn btn-secondary">Skip Validation</button>
            </div>

            <div class="status-message" id="validationStatus"></div>

            <!-- Validation Report -->
            <div id="validationReport" style="display: none;">
                <!-- Score Card -->
                <div class="validation-score-card" id="validationScoreCard">
                    <div class="score-display">
                        <div class="score-number" id="scoreNumber">--</div>
                        <div class="score-grade" id="scoreGrade">-</div>
                    </div>
                    <div class="score-message" id="scoreMessage">Validating...</div>
                </div>

                <!-- Summary Stats -->
                <div class="validation-summary" id="validationSummary"></div>

                <!-- Auto-Fix Section -->
                <div class="auto-fix-section" id="autoFixSection" style="display: none;">
                    <div class="auto-fix-banner">
                        <div class="auto-fix-info">
                            <h3>üîß Auto-Fix Available</h3>
                            <p id="autoFixCount">Some issues can be automatically fixed</p>
                        </div>
                        <button id="fixAllBtn" class="btn btn-primary btn-large">üîß Fix All Issues</button>
                    </div>
                    <div class="fix-progress" id="fixProgress" style="display: none;"></div>
                </div>

                <!-- Issues Breakdown -->
                <div class="issues-container" id="issuesContainer">
                    <!-- Critical Issues -->
                    <div class="issues-category critical-issues" id="criticalIssues" style="display: none;">
                        <h3 class="issues-header">üî¥ Critical Issues</h3>
                        <p class="issues-description">These must be fixed before Plainly deployment</p>
                        <div class="issues-list" id="criticalIssuesList"></div>
                    </div>

                    <!-- Warnings -->
                    <div class="issues-category warning-issues" id="warningIssues" style="display: none;">
                        <h3 class="issues-header">‚ö†Ô∏è Warnings</h3>
                        <p class="issues-description">Strongly recommended to fix for optimal performance</p>
                        <div class="issues-list" id="warningIssuesList"></div>
                    </div>

                    <!-- Info/Recommendations -->
                    <div class="issues-category info-issues" id="infoIssues" style="display: none;">
                        <h3 class="issues-header">‚ÑπÔ∏è Recommendations</h3>
                        <p class="issues-description">Best practices for performance optimization</p>
                        <div class="issues-list" id="infoIssuesList"></div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="validation-actions" id="validationActions">
                    <button id="downloadReportBtn" class="btn btn-secondary">üìÑ Download Report</button>
                    <button id="deployToPlainlyBtn" class="btn btn-success btn-large" style="display: none;">‚úÖ Deploy to Plainly</button>
                </div>
            </div>
        </section>

        <!-- Preview & Sign-off Section -->
        <section class="card preview-signoff-section" id="previewSignoffSection" style="display: none;">
            <h2>7. Preview & Sign-off</h2>

            <!-- Mode Badge -->
            <div class="mode-badge">
                {% if VALIDATE_BEFORE_PREVIEW %}
                    <span class="badge badge-green">Mode A: Validate ‚Üí Preview ‚Üí Sign-off ‚Üí Render</span>
                {% else %}
                    <span class="badge badge-blue">Mode B: Preview ‚Üí Validate ‚Üí Sign-off ‚Üí Render</span>
                {% endif %}
            </div>

            <!-- Generate Previews Button -->
            <div class="preview-controls">
                <button id="generatePreviewsBtn" class="btn btn-primary btn-large">
                    üé¨ Generate Side-by-Side Previews
                </button>
                <div class="status-message" id="previewGenStatus"></div>
            </div>

            <!-- Side-by-Side Preview -->
            <div id="previewContainer" class="two-col" style="display: none;">
                <!-- Left: PSD Reference -->
                <div class="panel">
                    <div class="panel-header">
                        <h3>PSD Reference</h3>
                        <div class="btn-row">
                            <a id="openPsdBtn" class="btn btn-secondary" download>üìÑ Download PSD</a>
                            <button id="regeneratePsdBtn" class="btn btn-secondary">üîÑ Regenerate</button>
                        </div>
                    </div>
                    <div class="panel-body">
                        <img id="psdPreviewImg" class="media-box" alt="PSD preview" />
                    </div>
                </div>

                <!-- Right: AE Preview -->
                <div class="panel">
                    <div class="panel-header">
                        <h3>After Effects Preview</h3>
                        <div class="btn-row">
                            <a id="openAepxBtn" class="btn btn-secondary" download>üé¨ Download AEPX</a>
                            <button id="regenerateAeBtn" class="btn btn-secondary">üîÑ Regenerate</button>
                        </div>
                    </div>
                    <div class="panel-body">
                        <video id="aePreviewVideo" class="media-box" controls preload="metadata"></video>
                    </div>
                </div>
            </div>

            <!-- Validation Summary Strip -->
            <div id="validationStrip" class="validation-strip" style="display: none;">
                <span class="strip-label">Validation Status:</span>
                <span id="validationBadge" class="badge"></span>
                <a id="viewReportLink" class="link" href="#validationSection">View Full Report</a>
            </div>

            <!-- Sign-off Card -->
            <div id="signoffCard" class="signoff-card" style="display: none;">
                <h3>‚úçÔ∏è Sign-off</h3>
                <p class="signoff-description">
                    I confirm the PSD render (left) and AE preview (right) match expectations and are ready for final production render.
                </p>
                <textarea id="signoffNotes" class="signoff-textarea" placeholder="Optional notes (e.g., 'Approved for client delivery')"></textarea>
                <label class="signoff-checkbox">
                    <input type="checkbox" id="signoffCheckbox">
                    <span>I approve this preview for final high-quality render</span>
                </label>
                <button id="approveBtn" class="btn btn-success btn-large" disabled>
                    ‚úÖ Approve & Start Final Render
                </button>
                <div id="signoffStatus" class="status-message"></div>
            </div>
        </section>
    </div>

    <script>
        // State
        let sessionId = null;
        let psdFile = null;
        let aepxFile = null;
        let currentMappings = [];
        let originalMappings = [];
        let allPsdLayers = [];
        let allPlaceholders = [];
        let unmappedPsdLayers = [];
        let unfilledPlaceholders = [];
        let fontsChecked = false;
        let missingFonts = [];

        // Visual mapping state
        let psdLayerPreviews = {};
        let aepxPlaceholderPreviews = {};
        let selectedPsdLayer = null;
        let previewsLoaded = false;

        // DOM Elements
        const psdDropZone = document.getElementById('psdDropZone');
        const aepxDropZone = document.getElementById('aepxDropZone');
        const psdInput = document.getElementById('psdInput');
        const aepxInput = document.getElementById('aepxInput');
        const fontInput = document.getElementById('fontInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const matchBtn = document.getElementById('matchBtn');
        const generateBtn = document.getElementById('generateBtn');
        const skipFontsBtn = document.getElementById('skipFontsBtn');

        // Utility: Show status message
        function showStatus(elementId, message, type = 'info') {
            const el = document.getElementById(elementId);
            el.textContent = message;
            el.className = `status-message status-${type}`;
            el.style.display = 'block';
        }

        // Utility: Hide status message
        function hideStatus(elementId) {
            document.getElementById(elementId).style.display = 'none';
        }

        // Setup drag & drop
        function setupDropZone(dropZone, input, infoId) {
            dropZone.addEventListener('click', () => input.click());

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                if (e.dataTransfer.files.length > 0) {
                    input.files = e.dataTransfer.files;
                    handleFileSelect(input, infoId);
                }
            });

            input.addEventListener('change', () => handleFileSelect(input, infoId));
        }

        // Handle file selection
        function handleFileSelect(input, infoId) {
            if (input.files.length > 0) {
                const file = input.files[0];
                const fileInfo = document.getElementById(infoId);
                fileInfo.innerHTML = `<strong>${file.name}</strong><br><small>${(file.size / 1024 / 1024).toFixed(2)} MB</small>`;

                if (input === psdInput) psdFile = file;
                if (input === aepxInput) aepxFile = file;

                // Enable upload button if both files selected
                uploadBtn.disabled = !(psdFile && aepxFile);
            }
        }

        // Upload files
        async function uploadFiles() {
            const formData = new FormData();
            formData.append('psd_file', psdFile);
            formData.append('aepx_file', aepxFile);

            uploadBtn.disabled = true;
            uploadBtn.textContent = 'Uploading...';
            showStatus('uploadStatus', 'Uploading and analyzing files...', 'info');

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    sessionId = result.data.session_id;
                    console.log("‚úÖ Session ID set after upload:", sessionId);
                    showStatus('uploadStatus', result.message, 'success');
                    displayFileInfo(result.data);
                    document.getElementById('infoSection').style.display = 'block';
                } else {
                    showStatus('uploadStatus', result.message, 'error');
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = 'Upload & Analyze';
                }
            } catch (error) {
                showStatus('uploadStatus', `Error: ${error.message}`, 'error');
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Upload & Analyze';
            }
        }

        // Display file info
        function displayFileInfo(data) {
            document.getElementById('psdDetails').innerHTML = `
                <p><strong>File:</strong> ${data.psd.filename}</p>
                <p><strong>Dimensions:</strong> ${data.psd.width} √ó ${data.psd.height}</p>
                <p><strong>Layers:</strong> ${data.psd.layers}</p>
            `;

            document.getElementById('aepxDetails').innerHTML = `
                <p><strong>File:</strong> ${data.aepx.filename}</p>
                <p><strong>Composition:</strong> ${data.aepx.composition}</p>
                <p><strong>Placeholders:</strong> ${data.aepx.placeholders}</p>
            `;

            let fontHtml = `<p><strong>Total Fonts:</strong> ${data.fonts.total}</p>`;
            if (data.fonts.uncommon > 0) {
                fontHtml += `<p class="warning"><strong>Uncommon Fonts:</strong> ${data.fonts.uncommon}</p>`;
                fontHtml += `<ul class="font-list">`;
                data.fonts.uncommon_list.forEach(font => {
                    fontHtml += `<li>${font}</li>`;
                });
                fontHtml += `</ul>`;
            } else {
                fontHtml += `<p class="success">All fonts are common</p>`;
            }
            document.getElementById('fontDetails').innerHTML = fontHtml;

            // Auto-check fonts
            checkFonts();
        }

        // Check fonts
        async function checkFonts() {
            try {
                const response = await fetch('/check-fonts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                });

                const result = await response.json();

                if (result.success) {
                    displayFontStatus(result.data);
                    document.getElementById('fontSection').style.display = 'block';
                }
            } catch (error) {
                console.error('Error checking fonts:', error);
            }
        }

        // Display font status
        function displayFontStatus(data) {
            missingFonts = data.missing_fonts || [];
            const statusEl = document.getElementById('fontStatus');
            const listEl = document.getElementById('fontList');

            if (data.missing_count === 0) {
                statusEl.innerHTML = '<p class="success">‚úÖ All required fonts are available!</p>';
                fontsChecked = true;
                document.getElementById('matchBtn').style.display = 'inline-block';
            } else {
                statusEl.innerHTML = `<p class="warning">‚ö†Ô∏è ${data.missing_count} font(s) missing</p>`;
                document.getElementById('fontActions').style.display = 'block';
            }

            // Display fonts as visual cards
            let html = '<div class="font-cards-grid">';

            // Show required fonts with status
            data.required_fonts.forEach(font => {
                const isMissing = data.missing_fonts.includes(font);
                const isInstalled = data.installed_fonts.includes(font);
                const previewPath = data.previews && data.previews[font] ? data.previews[font] : null;
                const metadata = data.metadata && data.metadata[font] ? data.metadata[font] : null;

                // Card class based on status
                const cardClass = isInstalled ? 'font-card-installed' : 'font-card-missing';

                html += `
                    <div class="font-card ${cardClass}">
                        <div class="font-card-header">
                            <div class="font-card-status">
                                <span class="status-badge ${isInstalled ? 'status-success' : 'status-error'}">
                                    ${isInstalled ? '‚úì Installed' : '‚úó Missing'}
                                </span>
                            </div>
                            <h4 class="font-card-name">${font}</h4>
                        </div>

                        <div class="font-card-preview">
                            ${previewPath ? `<img src="${previewPath}" alt="${font} preview" class="font-preview-image">` : '<div class="font-preview-placeholder">No preview</div>'}
                        </div>

                        <div class="font-card-footer">
                            ${metadata ? `
                                <div class="font-metadata">
                                    <span class="font-format">${metadata.format}</span>
                                    <span class="font-size">${metadata.size}</span>
                                </div>
                            ` : ''}
                            ${isMissing ? `
                                <button class="btn btn-small btn-upload-font" onclick="document.getElementById('fontInput').click()">
                                    Upload Font
                                </button>
                            ` : ''}
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            listEl.innerHTML = html;
        }

        // Upload fonts
        async function uploadFonts() {
            const files = fontInput.files;
            if (files.length === 0) return;

            const formData = new FormData();
            for (let i = 0; i < files.length; i++) {
                formData.append('font_files', files[i]);
            }

            showStatus('fontUploadStatus', 'Uploading fonts...', 'info');

            try {
                const response = await fetch('/upload-fonts', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    showStatus('fontUploadStatus', result.message, 'success');
                    // Re-check fonts after upload
                    checkFonts();
                    fontInput.value = '';
                } else {
                    showStatus('fontUploadStatus', result.message, 'error');
                }
            } catch (error) {
                showStatus('fontUploadStatus', `Error: ${error.message}`, 'error');
            }
        }

        // Skip font check
        function skipFonts() {
            fontsChecked = true;
            document.getElementById('matchBtn').style.display = 'inline-block';
            document.getElementById('fontActions').style.display = 'none';
            showStatus('fontUploadStatus', 'Continuing without font check. Ensure fonts are installed in After Effects.', 'info');
        }

        // Match content
        async function matchContent() {
            matchBtn.disabled = true;
            matchBtn.textContent = 'Matching...';

            try {
                const response = await fetch('/match', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                });

                const result = await response.json();

                if (result.success) {
                    currentMappings = result.data.mappings;
                    originalMappings = JSON.parse(JSON.stringify(result.data.mappings));

                    // Extract all layers and placeholders for visual mapping
                    console.log('üîç Auto-Match Result Data:', result.data);
                    console.log('üîç Mappings:', result.data.mappings);
                    allPsdLayers = result.data.mappings.map(m => m.psd_layer)
                        .concat(result.data.unmapped_psd || []);
                    allPlaceholders = result.data.mappings.map(m => m.aepx_placeholder)
                        .concat(result.data.unfilled_placeholders || []);
                    console.log('üì¶ Extracted allPsdLayers:', allPsdLayers);
                    console.log('üì¶ Extracted allPlaceholders:', allPlaceholders);

                    displayMappings(result.data);
                    displayConflicts(result.data.conflicts);
                    document.getElementById('mappingsSection').style.display = 'block';
                    document.getElementById('conflictsSection').style.display = 'block';
                    document.getElementById('previewSection').style.display = 'block';

                    // Show clear success notification with stats
                    const totalMapped = result.data.mappings.length;
                    const unmappedCount = (result.data.unmapped_psd || []).length;
                    const avgConfidence = result.data.statistics?.average_confidence
                        ? (result.data.statistics.average_confidence * 100).toFixed(0)
                        : 'N/A';

                    let message = `‚úÖ Auto-matched ${totalMapped} layer${totalMapped !== 1 ? 's' : ''} (${avgConfidence}% confidence)`;
                    if (unmappedCount > 0) {
                        message += `\n‚ö†Ô∏è ${unmappedCount} layer${unmappedCount !== 1 ? 's' : ''} unmapped - use Visual Mapper to map manually`;
                    }

                    alert(message);
                } else {
                    alert(result.message);
                    matchBtn.disabled = false;
                    matchBtn.textContent = 'Match Content';
                }
            } catch (error) {
                alert(`Error: ${error.message}`);
                matchBtn.disabled = false;
                matchBtn.textContent = 'Match Content';
            }
        }

        // Display mappings
        function displayMappings(data) {
            const mappingsList = document.getElementById('mappingsList');
            let html = '<div class="mappings-grid">';

            data.mappings.forEach((mapping, index) => {
                const confidence = (mapping.confidence * 100).toFixed(0);
                const confidenceClass = mapping.confidence >= 0.9 ? 'high' :
                                       mapping.confidence >= 0.6 ? 'medium' : 'low';
                const icon = mapping.type === 'text' ? 'üìù' : 'üñºÔ∏è';

                html += `
                    <div class="mapping-card">
                        <div class="mapping-header">
                            <span class="mapping-icon">${icon}</span>
                            <span class="mapping-type">${mapping.type}</span>
                            <span class="confidence confidence-${confidenceClass}">${confidence}%</span>
                        </div>
                        <div class="mapping-content">
                            <div class="mapping-source">
                                <strong>PSD:</strong> ${mapping.psd_layer}
                            </div>
                            <div class="mapping-arrow">‚Üí</div>
                            <div class="mapping-target">
                                <strong>Template:</strong> ${mapping.aepx_placeholder}
                            </div>
                        </div>
                        <div class="mapping-actions">
                            <button class="btn-preview-mapping"
                                    onclick="previewMapping('${mapping.psd_layer}', '${mapping.aepx_placeholder}')">
                                üëÅ Preview Mapping
                            </button>
                        </div>
                    </div>
                `;
            });

            html += '</div>';

            // Add stats
            const statsHtml = `
                <p><strong>Mappings Created:</strong> ${data.mappings.length}</p>
                ${data.unmapped_psd.length > 0 ? `<p class="warning"><strong>Unmapped PSD Layers:</strong> ${data.unmapped_psd.join(', ')}</p>` : ''}
                ${data.unfilled_placeholders.length > 0 ? `<p class="warning"><strong>Unfilled Placeholders:</strong> ${data.unfilled_placeholders.join(', ')}</p>` : ''}
            `;

            mappingsList.innerHTML = html;
            document.getElementById('mappingStats').innerHTML = statsHtml;
        }

        // Visual Mapping Functions
        async function loadVisualPreviews() {
            const loadBtn = document.getElementById('loadPreviewsBtn');
            const statusEl = document.getElementById('mappingLoadStatus');

            loadBtn.disabled = true;
            statusEl.textContent = '‚è≥ Generating layer thumbnails...';
            statusEl.className = 'status-message status-info';
            statusEl.style.display = 'block';

            try {
                // Create placeholder preview data initially
                psdLayerPreviews = {};
                allPsdLayers.forEach(layer => {
                    psdLayerPreviews[layer] = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150"><rect width="200" height="150" fill="%23e0e0e0"/><text x="50%" y="50%" text-anchor="middle" dy=".3em" font-size="14" fill="%23333">Loading...</text></svg>';
                });

                aepxPlaceholderPreviews = {};
                allPlaceholders.forEach(placeholder => {
                    aepxPlaceholderPreviews[placeholder] = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150"><rect width="200" height="150" fill="%23f0f0f0"/><text x="50%" y="50%" text-anchor="middle" dy=".3em" font-size="14" fill="%23666">No Preview</text></svg>';
                });

                previewsLoaded = true;

                // Display visual mapping interface with placeholders
                displayVisualMappingInterface();

                // Generate real thumbnails in background
                statusEl.textContent = '‚è≥ Generating real layer previews with Photoshop...';

                try {
                    console.log("üîç About to generate thumbnails with sessionId:", sessionId);
                    const requestBody = { session_id: sessionId };
                    console.log("üì§ Sending to /generate-thumbnails:", requestBody);

                    const response = await fetch('/generate-thumbnails', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });

                    const result = await response.json();
                    console.log("üì• Received response from /generate-thumbnails:", result);

                    if (result.success) {
                        console.log('‚úÖ Thumbnails generated:', result.thumbnails);
                        console.log('üìã Backend returned keys:', Object.keys(result.thumbnails));
                        console.log('üìã Frontend expects keys:', Object.keys(psdLayerPreviews));

                        // Check for key mismatches
                        const backendKeys = Object.keys(result.thumbnails);
                        const frontendKeys = Object.keys(psdLayerPreviews);
                        const matches = backendKeys.filter(k => frontendKeys.includes(k));
                        const mismatches = backendKeys.filter(k => !frontendKeys.includes(k));

                        console.log(`‚úì ${matches.length} matching keys:`, matches);
                        if (mismatches.length > 0) {
                            console.warn(`‚ö†Ô∏è ${mismatches.length} non-matching keys:`, mismatches);
                        }

                        // Update preview URLs with real thumbnails
                        updateLayerPreviews(result.thumbnails);

                        // Re-render the interface to show the updated thumbnails
                        displayVisualMappingInterface();

                        statusEl.textContent = `‚úÖ Generated ${Object.keys(result.thumbnails).length} layer previews`;
                        statusEl.className = 'status-message status-success';
                    } else {
                        console.warn('Thumbnail generation failed, using placeholders');
                        statusEl.textContent = '‚ö†Ô∏è Using placeholder previews (thumbnail generation unavailable)';
                        statusEl.className = 'status-message status-warning';
                    }
                } catch (thumbnailError) {
                    console.warn('Thumbnail generation error:', thumbnailError);
                    statusEl.textContent = '‚ö†Ô∏è Using placeholder previews';
                    statusEl.className = 'status-message status-warning';
                }

                // Hide load button after successful load
                setTimeout(() => {
                    loadBtn.style.display = 'none';
                }, 3000);

            } catch (error) {
                statusEl.textContent = `‚ùå ${error.message}`;
                statusEl.className = 'status-message status-error';
                loadBtn.disabled = false;
            }
        }

        function updateLayerPreviews(thumbnails) {
            // Update PSD layer previews with real thumbnails
            console.log(`Updating ${Object.keys(thumbnails).length} layer previews...`);

            for (const [layerName, thumbUrl] of Object.entries(thumbnails)) {
                console.log(`  - ${layerName}: ${thumbUrl}`);

                // Update in preview data
                if (psdLayerPreviews.hasOwnProperty(layerName)) {
                    psdLayerPreviews[layerName] = thumbUrl;
                    console.log(`    ‚úì Updated preview data for ${layerName}`);
                } else {
                    console.warn(`    ‚ö†Ô∏è Layer not found in psdLayerPreviews: ${layerName}`);
                }

                // Update rendered preview images in DOM
                const previewImg = document.querySelector(`[data-layer-preview="${layerName}"]`);
                if (previewImg) {
                    previewImg.src = thumbUrl;
                    previewImg.classList.remove('placeholder');
                    previewImg.classList.add('loaded');
                    console.log(`    ‚úì Updated DOM image for ${layerName}`);
                } else {
                    console.warn(`    ‚ö†Ô∏è DOM image not found for ${layerName}`);
                }
            }

            // Update AEPX placeholder thumbnails based on current mappings
            console.log('Updating AEPX placeholder thumbnails based on mappings...');
            for (const mapping of currentMappings) {
                const thumbnailUrl = thumbnails[mapping.psd_layer];
                if (thumbnailUrl) {
                    const placeholderImg = document.querySelector(
                        `[data-placeholder-preview="${mapping.aepx_placeholder}"]`
                    );
                    if (placeholderImg) {
                        placeholderImg.src = thumbnailUrl;
                        placeholderImg.classList.remove('placeholder');
                        placeholderImg.classList.add('loaded');
                        console.log(`    ‚úì Updated AEPX placeholder "${mapping.aepx_placeholder}" with thumbnail from "${mapping.psd_layer}"`);
                    } else {
                        console.warn(`    ‚ö†Ô∏è AEPX placeholder image not found for ${mapping.aepx_placeholder}`);
                    }
                }
            }

            console.log('‚úÖ Preview update complete');
        }

        function displayVisualMappingInterface() {
            const container = document.getElementById('visualMappingContainer');
            const psdGrid = document.getElementById('psdLayersGrid');
            const aepxGrid = document.getElementById('aepxPlaceholdersGrid');

            // Show container
            container.style.display = 'grid';

            // DIAGNOSTIC LOGGING
            console.log('='.repeat(70));
            console.log('DISPLAY VISUAL MAPPING INTERFACE');
            console.log('='.repeat(70));
            console.log('üì¶ allPsdLayers:', allPsdLayers);
            console.log('üì¶ allPlaceholders:', allPlaceholders);
            console.log('üîó currentMappings:', currentMappings);
            console.log('='.repeat(70));

            // Render PSD layers
            psdGrid.innerHTML = '';
            allPsdLayers.forEach(layerName => {
                const previewUrl = psdLayerPreviews[layerName];
                const isMapped = currentMappings.some(m => m.psd_layer === layerName);

                // Check if this is a real thumbnail or placeholder
                const isPlaceholder = !previewUrl || previewUrl.startsWith('data:image/svg+xml');
                const imageClass = isPlaceholder ? 'preview-image placeholder' : 'preview-image loaded';

                const item = document.createElement('div');
                item.className = `preview-item ${isMapped ? 'mapped' : ''}`;
                item.dataset.layerName = layerName;
                item.innerHTML = `
                    <img src="${previewUrl}" alt="${layerName}" class="${imageClass}"
                         data-layer-preview="${layerName}"
                         onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22><text x=%2250%%22 y=%2250%%22 text-anchor=%22middle%22 dy=%22.3em%22>?</text></svg>'">
                    <div class="preview-name">${layerName}</div>
                    <div class="preview-type">PSD Layer</div>
                `;

                item.addEventListener('click', () => selectPsdLayer(layerName, item));
                psdGrid.appendChild(item);
            });

            // Render AEPX placeholders
            aepxGrid.innerHTML = '';
            allPlaceholders.forEach(placeholderName => {
                // Check if this placeholder is mapped to a PSD layer
                const mapping = currentMappings.find(m => m.aepx_placeholder === placeholderName);
                const isMapped = !!mapping;

                // If mapped, use the PSD layer's thumbnail; otherwise use placeholder preview
                let previewUrl;
                if (mapping && mapping.psd_layer && psdLayerPreviews[mapping.psd_layer]) {
                    previewUrl = psdLayerPreviews[mapping.psd_layer];
                    console.log(`Placeholder "${placeholderName}" mapped to "${mapping.psd_layer}", using its thumbnail`);
                } else {
                    previewUrl = aepxPlaceholderPreviews[placeholderName] || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150"><rect width="200" height="150" fill="%23f0f0f0"/><text x="50%" y="50%" text-anchor="middle" dy=".3em" font-size="14" fill="%23999">No Preview</text></svg>';
                }

                // Check if this is a real thumbnail or placeholder
                const isPlaceholder = !previewUrl || previewUrl.startsWith('data:image/svg+xml');
                const imageClass = isPlaceholder ? 'preview-image placeholder' : 'preview-image loaded';

                const item = document.createElement('div');
                item.className = `preview-item ${isMapped ? 'mapped' : ''}`;
                item.dataset.placeholderName = placeholderName;
                item.innerHTML = `
                    <img src="${previewUrl}" alt="${placeholderName}" class="${imageClass}"
                         data-placeholder-preview="${placeholderName}"
                         onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22><text x=%2250%%22 y=%2250%%22 text-anchor=%22middle%22 dy=%22.3em%22>?</text></svg>'">
                    <div class="preview-name">${placeholderName}</div>
                    <div class="preview-type">AEPX Placeholder</div>
                `;

                item.addEventListener('click', () => selectAepxPlaceholder(placeholderName));
                aepxGrid.appendChild(item);
            });

            // Add "Additional Layers" section for unmapped PSD layers
            const mappedPsdLayers = new Set(currentMappings.map(m => m.psd_layer));
            const unmappedLayers = allPsdLayers.filter(layer => !mappedPsdLayers.has(layer));

            if (unmappedLayers.length > 0) {
                // Add section header
                const sectionHeader = document.createElement('div');
                sectionHeader.className = 'additional-layers-header';
                sectionHeader.innerHTML = `
                    <h4 style="margin: 20px 0 10px 0; padding: 10px; background: #e3f2fd; border-radius: 6px; color: #1976d2;">
                        üìã Additional Layers (${unmappedLayers.length})
                        <span style="font-size: 12px; font-weight: normal; color: #666; display: block; margin-top: 5px;">
                            These layers will be added to the composition
                        </span>
                    </h4>
                `;
                aepxGrid.appendChild(sectionHeader);

                // Render each unmapped layer
                unmappedLayers.forEach(layerName => {
                    const previewUrl = psdLayerPreviews[layerName] || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150"><rect width="200" height="150" fill="%23e3f2fd"/><text x="50%" y="50%" text-anchor="middle" dy=".3em" font-size="14" fill="%231976d2">Additional Layer</text></svg>';
                    const isPlaceholder = !psdLayerPreviews[layerName] || previewUrl.startsWith('data:image/svg+xml');
                    const imageClass = isPlaceholder ? 'preview-image placeholder' : 'preview-image loaded';

                    const item = document.createElement('div');
                    item.className = 'preview-item additional-layer';
                    item.dataset.layerName = layerName;
                    item.innerHTML = `
                        <img src="${previewUrl}" alt="${layerName}" class="${imageClass}"
                             data-layer-preview="${layerName}"
                             onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22><text x=%2250%%22 y=%2250%%22 text-anchor=%22middle%22 dy=%22.3em%22>?</text></svg>'">
                        <div class="preview-name">${layerName}</div>
                        <div class="preview-type" style="background: #1976d2; color: white;">Will be added as layer</div>
                    `;

                    aepxGrid.appendChild(item);
                });

                console.log(`üìã Added ${unmappedLayers.length} additional unmapped layers to display`);
            }

            // Update mappings list
            updateVisualMappingsList();
        }

        function selectPsdLayer(layerName, element) {
            // Deselect previous selection
            document.querySelectorAll('#psdLayersGrid .preview-item').forEach(el => {
                el.classList.remove('selected');
            });

            // Select this layer
            selectedPsdLayer = layerName;
            element.classList.add('selected');

            // Show clear selection button
            document.getElementById('clearSelectionBtn').style.display = 'inline-block';

            showStatus('mappingLoadStatus', `Selected PSD layer: ${layerName}. Now click an AEPX placeholder to create mapping.`, 'info');
        }

        function selectAepxPlaceholder(placeholderName) {
            if (!selectedPsdLayer) {
                showStatus('mappingLoadStatus', 'Please select a PSD layer first', 'warning');
                return;
            }

            // Check if placeholder is already mapped
            const existingMappingIndex = currentMappings.findIndex(m => m.aepx_placeholder === placeholderName);
            if (existingMappingIndex !== -1) {
                // Remove existing mapping for this placeholder
                currentMappings.splice(existingMappingIndex, 1);
            }

            // Check if PSD layer is already mapped
            const psdMappingIndex = currentMappings.findIndex(m => m.psd_layer === selectedPsdLayer);
            if (psdMappingIndex !== -1) {
                // Remove existing mapping for this PSD layer
                currentMappings.splice(psdMappingIndex, 1);
            }

            // Create new mapping
            currentMappings.push({
                psd_layer: selectedPsdLayer,
                aepx_placeholder: placeholderName,
                type: 'manual',
                confidence: 1.0
            });

            showStatus('mappingLoadStatus', `‚úÖ Mapped ${selectedPsdLayer} ‚Üí ${placeholderName}`, 'success');

            // Clear selection
            clearPsdSelection();

            // Update visual display
            displayVisualMappingInterface();
        }

        function clearPsdSelection() {
            selectedPsdLayer = null;
            document.querySelectorAll('#psdLayersGrid .preview-item').forEach(el => {
                el.classList.remove('selected');
            });
            document.getElementById('clearSelectionBtn').style.display = 'none';
        }

        function updateVisualMappingsList() {
            const mappingsList = document.getElementById('mappingsList');
            const statsEl = document.getElementById('mappingStats');

            if (currentMappings.length === 0) {
                mappingsList.innerHTML = '<p style="text-align: center; color: #666;">No mappings yet</p>';
            } else {
                let html = '';
                currentMappings.forEach((mapping, index) => {
                    html += `
                        <div class="mapping-item-compact">
                            <div class="mapping-pair">
                                <div class="from-layer">üìÑ ${mapping.psd_layer}</div>
                                <div style="text-align: center; color: #999;">‚Üì</div>
                                <div class="to-placeholder">üé¨ ${mapping.aepx_placeholder}</div>
                            </div>
                            <button class="delete-mapping" onclick="deleteVisualMapping(${index})">Delete</button>
                        </div>
                    `;
                });
                mappingsList.innerHTML = html;
            }

            // Update stats
            const mappedPsdCount = new Set(currentMappings.map(m => m.psd_layer)).size;
            const mappedPlaceholdersCount = new Set(currentMappings.map(m => m.aepx_placeholder)).size;
            const additionalLayersCount = allPsdLayers.length - mappedPsdCount;
            const unmappedPlaceholdersCount = allPlaceholders.length - mappedPlaceholdersCount;

            // Determine if all layers are handled
            const allLayersHandled = (mappedPsdCount + additionalLayersCount) === allPsdLayers.length;

            statsEl.innerHTML = `
                <p class="info-text" style="margin-bottom: 15px; padding: 12px; background: #e8f5e9; border-left: 4px solid #4caf50; border-radius: 4px; color: #2e7d32; font-size: 14px;">
                    ${allLayersHandled ? '‚úÖ' : '‚ö†Ô∏è'} All ${allPsdLayers.length} PSD layers are handled: ${mappedPsdCount} will replace placeholders${additionalLayersCount > 0 ? `, ${additionalLayersCount} will be added as additional layers` : ''}.
                </p>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                    <div class="stat-item success">
                        <div class="stat-number">${allPsdLayers.length}</div>
                        <div class="stat-label">Total Layers</div>
                    </div>
                    <div class="stat-item success">
                        <div class="stat-number">${mappedPsdCount}</div>
                        <div class="stat-label">Mapped to Placeholders</div>
                    </div>
                    <div class="stat-item info">
                        <div class="stat-number">${additionalLayersCount}</div>
                        <div class="stat-label">Added as Layers</div>
                    </div>
                    <div class="stat-item ${unmappedPlaceholdersCount === 0 ? 'success' : 'warning'}">
                        <div class="stat-number">${unmappedPlaceholdersCount}</div>
                        <div class="stat-label">Unfilled Placeholders</div>
                    </div>
                </div>
            `;
        }

        function deleteVisualMapping(index) {
            currentMappings.splice(index, 1);
            displayVisualMappingInterface();
            showStatus('mappingLoadStatus', 'Mapping deleted', 'info');
        }

        function resetMappings() {
            if (confirm('Reset to auto-generated mappings? This will discard your manual changes.')) {
                currentMappings = JSON.parse(JSON.stringify(originalMappings));
                if (previewsLoaded) {
                    displayVisualMappingInterface();
                }
                showStatus('mappingLoadStatus', '‚úÖ Mappings reset to auto-match', 'success');
            }
        }

        // Display conflicts
        function displayConflicts(conflicts) {
            const summary = document.getElementById('conflictSummary');
            const list = document.getElementById('conflictsList');

            const summaryHtml = `
                <div class="conflict-stats">
                    <div class="stat-item">
                        <span class="stat-number">${conflicts.total}</span>
                        <span class="stat-label">Total Issues</span>
                    </div>
                    <div class="stat-item critical">
                        <span class="stat-number">${conflicts.critical}</span>
                        <span class="stat-label">Critical</span>
                    </div>
                    <div class="stat-item warning">
                        <span class="stat-number">${conflicts.warning}</span>
                        <span class="stat-label">Warnings</span>
                    </div>
                    <div class="stat-item info">
                        <span class="stat-number">${conflicts.info}</span>
                        <span class="stat-label">Info</span>
                    </div>
                </div>
            `;

            let listHtml = '';
            if (conflicts.items.length > 0) {
                listHtml = '<div class="conflicts-list">';
                conflicts.items.forEach(conflict => {
                    const icon = conflict.severity === 'critical' ? 'üî¥' :
                                conflict.severity === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
                    const resolutionOptions = conflict.resolution_options || [];
                    const isResolved = conflict.resolved || false;

                    listHtml += `
                        <div class="conflict-item conflict-${conflict.severity} ${isResolved ? 'resolved' : ''}" data-conflict-id="${conflict.id}">
                            <span class="conflict-icon">${icon}</span>
                            <div class="conflict-details">
                                <strong>${conflict.type}</strong>
                                <p>${conflict.issue}</p>
                                ${conflict.suggestion ? `<p class="suggestion">üí° ${conflict.suggestion}</p>` : ''}

                                ${resolutionOptions.length > 0 ? `
                                    <div class="resolution-options">
                                        <h4>Resolution Options:</h4>
                                        ${resolutionOptions.map(option => `
                                            <div class="resolution-option ${option.is_default ? 'default' : ''}">
                                                <input type="radio"
                                                       name="resolution_${conflict.id}"
                                                       id="${conflict.id}_${option.id}"
                                                       value="${option.id}"
                                                       ${option.is_default ? 'checked' : ''}
                                                       ${isResolved ? 'disabled' : ''}>
                                                <label for="${conflict.id}_${option.id}">
                                                    <strong>${option.label}</strong>
                                                    ${option.is_default ? '<span class="badge-default">Recommended</span>' : ''}
                                                    <p class="option-description">${option.description}</p>
                                                </label>
                                            </div>
                                        `).join('')}

                                        <button class="btn btn-primary btn-small apply-resolution-btn"
                                                onclick="applyResolution('${conflict.id}')"
                                                ${isResolved ? 'disabled' : ''}>
                                            ${isResolved ? '‚úì Resolved' : 'Apply Resolution'}
                                        </button>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                });
                listHtml += '</div>';
            } else {
                listHtml = '<p class="success">‚úÖ No conflicts detected!</p>';
            }

            summary.innerHTML = summaryHtml;
            list.innerHTML = listHtml;
        }

        async function applyResolution(conflictId) {
            const selectedOption = document.querySelector(`input[name="resolution_${conflictId}"]:checked`);

            if (!selectedOption) {
                showNotification('error', 'Please select a resolution option');
                return;
            }

            const resolutionId = selectedOption.value;

            // Disable button and show loading state
            const conflictCard = document.querySelector(`[data-conflict-id="${conflictId}"]`);
            const applyBtn = conflictCard.querySelector('.apply-resolution-btn');
            const originalText = applyBtn.textContent;
            applyBtn.disabled = true;
            applyBtn.textContent = 'Applying...';

            try {
                const response = await fetch('/apply-resolution', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        conflict_id: conflictId,
                        resolution_id: resolutionId
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Mark conflict as resolved in UI
                    conflictCard.classList.add('resolved');
                    applyBtn.textContent = '‚úì Resolved';
                    applyBtn.disabled = true;

                    // Disable radio buttons
                    conflictCard.querySelectorAll('input[type="radio"]').forEach(input => {
                        input.disabled = true;
                    });

                    showNotification('success', result.message || 'Resolution applied successfully');

                    // Update conflict counts if function exists
                    if (typeof updateConflictCounts === 'function') {
                        updateConflictCounts();
                    }
                } else {
                    // Re-enable button on failure
                    applyBtn.disabled = false;
                    applyBtn.textContent = originalText;
                    showNotification('error', result.message || 'Failed to apply resolution');
                }
            } catch (error) {
                // Re-enable button on error
                applyBtn.disabled = false;
                applyBtn.textContent = originalText;
                showNotification('error', 'Error applying resolution: ' + error.message);
            }
        }

        // Toast notification system
        function showNotification(type, message) {
            // Create toast container if it doesn't exist
            let toastContainer = document.getElementById('toastContainer');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toastContainer';
                toastContainer.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 10000;
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                `;
                document.body.appendChild(toastContainer);
            }

            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;

            // Icon based on type
            const icons = {
                success: '‚úì',
                error: '‚úó',
                info: '‚Ñπ',
                warning: '‚ö†'
            };
            const icon = icons[type] || '‚Ñπ';

            toast.innerHTML = `
                <span class="toast-icon">${icon}</span>
                <span class="toast-message">${message}</span>
            `;

            toast.style.cssText = `
                background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : type === 'warning' ? '#f59e0b' : '#3b82f6'};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                display: flex;
                align-items: center;
                gap: 10px;
                min-width: 250px;
                max-width: 400px;
                animation: slideIn 0.3s ease-out;
            `;

            toastContainer.appendChild(toast);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => {
                    toast.remove();
                    // Remove container if empty
                    if (toastContainer.children.length === 0) {
                        toastContainer.remove();
                    }
                }, 300);
            }, 3000);
        }

        // Generate script
        async function generateScript() {
            generateBtn.disabled = true;
            generateBtn.textContent = 'Generating...';
            showStatus('generateStatus', 'Generating ExtendScript...', 'info');

            try {
                const response = await fetch('/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        mappings: currentMappings
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showStatus('generateStatus', result.message, 'success');
                    displayDownload(result.data);
                } else {
                    showStatus('generateStatus', result.message, 'error');
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Generate ExtendScript';
                }
            } catch (error) {
                showStatus('generateStatus', `Error: ${error.message}`, 'error');
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate ExtendScript';
            }
        }

        // Display download
        function displayDownload(data) {
            const downloadLink = document.getElementById('downloadLink');
            downloadLink.href = data.download_url;
            downloadLink.download = data.filename;
            document.getElementById('downloadSection').style.display = 'block';

            // Show validation section
            document.getElementById('validationSection').style.display = 'block';
            document.getElementById('validationSection').scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Show preview & sign-off section
            const previewSection = document.getElementById('previewSignoffSection');
            if (previewSection) {
                previewSection.style.display = 'block';
            }
        }

        // Generate preview
        async function generatePreview() {
            const generatePreviewBtn = document.getElementById('generatePreviewBtn');
            const skipPreviewBtn = document.getElementById('skipPreviewBtn');

            generatePreviewBtn.disabled = true;
            skipPreviewBtn.disabled = true;
            showStatus('previewStatus', 'Generating preview... This may take 10-30 seconds.', 'info');

            try {
                const response = await fetch('/generate-preview', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        options: {
                            resolution: 'half',
                            duration: 5.0,
                            format: 'mp4',
                            quality: 'draft',
                            fps: 15
                        }
                    })
                });

                const result = await response.json();

                if (result.success) {
                    displayPreview(result.data);
                    showStatus('previewStatus', 'Preview generated successfully!', 'success');
                } else {
                    if (result.aerender_available === false) {
                        showStatus('previewStatus', result.message + ' You can skip preview and generate script directly.', 'error');
                        skipPreviewBtn.disabled = false;
                    } else {
                        showStatus('previewStatus', result.message, 'error');
                    }
                    generatePreviewBtn.disabled = false;
                    skipPreviewBtn.disabled = false;
                }
            } catch (error) {
                showStatus('previewStatus', 'Error: ' + error.message, 'error');
                generatePreviewBtn.disabled = false;
                skipPreviewBtn.disabled = false;
            }
        }

        // Display preview video
        function displayPreview(data) {
            const previewPlayer = document.getElementById('previewPlayer');
            const previewVideo = document.getElementById('previewVideo');
            const previewSource = document.getElementById('previewSource');
            const previewInfo = document.getElementById('previewInfo');
            const previewControls = document.getElementById('previewControls');

            // Set video source
            previewSource.src = data.preview_url;
            previewVideo.load();

            // Display preview info
            let infoHTML = '<p style="color: var(--text-secondary);">';
            if (data.resolution) {
                infoHTML += `<strong>Resolution:</strong> ${data.resolution} &nbsp;&nbsp;`;
            }
            if (data.duration) {
                infoHTML += `<strong>Duration:</strong> ${data.duration.toFixed(1)}s`;
            }
            infoHTML += '</p>';
            previewInfo.innerHTML = infoHTML;

            // Show player, hide controls
            previewPlayer.style.display = 'block';
            previewControls.style.display = 'none';
        }

        // Skip preview
        function skipPreview() {
            document.getElementById('previewSection').style.display = 'none';
            document.getElementById('generateSection').style.display = 'block';
        }

        // Proceed to generate script after preview
        function proceedToGenerate() {
            document.getElementById('generateSection').style.display = 'block';
            window.scrollTo({
                top: document.getElementById('generateSection').offsetTop - 20,
                behavior: 'smooth'
            });
        }

        // Event listeners
        setupDropZone(psdDropZone, psdInput, 'psdInfo');
        setupDropZone(aepxDropZone, aepxInput, 'aepxInfo');
        uploadBtn.addEventListener('click', uploadFiles);
        fontInput.addEventListener('change', uploadFonts);
        skipFontsBtn.addEventListener('click', skipFonts);
        matchBtn.addEventListener('click', matchContent);
        document.getElementById('loadPreviewsBtn').addEventListener('click', loadVisualPreviews);
        document.getElementById('resetMappingsBtn').addEventListener('click', resetMappings);
        document.getElementById('clearSelectionBtn').addEventListener('click', clearPsdSelection);
        document.getElementById('generatePreviewBtn').addEventListener('click', generatePreview);
        document.getElementById('skipPreviewBtn').addEventListener('click', skipPreview);
        document.getElementById('proceedToGenerateBtn').addEventListener('click', proceedToGenerate);
        generateBtn.addEventListener('click', generateScript);
        document.getElementById('validatePlainlyBtn').addEventListener('click', validatePlainly);
        document.getElementById('skipValidationBtn').addEventListener('click', skipValidation);
        document.getElementById('downloadReportBtn').addEventListener('click', downloadValidationReport);
        document.getElementById('fixAllBtn').addEventListener('click', applyAutoFixes);

        // Preview mapping function
        async function previewMapping(psdLayer, aepxPlaceholder) {
            try {
                showStatus('mappingStatus', 'Generating preview...', 'info');

                const response = await fetch('/generate-mapping-preview', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        psd_layer: psdLayer,
                        aepx_placeholder: aepxPlaceholder
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showStatus('mappingStatus', '', 'info');
                    showMappingPreviewModal(result, psdLayer, aepxPlaceholder);
                } else {
                    showStatus('mappingStatus', `Preview failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Error generating mapping preview:', error);
                showStatus('mappingStatus', `Error: ${error.message}`, 'error');
            }
        }

        // Show mapping preview modal
        function showMappingPreviewModal(previewData, psdLayer, aepxPlaceholder) {
            const modal = document.getElementById('mappingPreviewModal');
            document.getElementById('modalPsdLayer').textContent = psdLayer;
            document.getElementById('modalAepxPlaceholder').textContent = aepxPlaceholder;
            document.getElementById('modalCompositeImage').src = previewData.preview_path;
            modal.style.display = 'flex';
        }

        // Close modal when clicking outside or on close button
        window.onclick = function(event) {
            const modal = document.getElementById('mappingPreviewModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }

        function closeMappingPreviewModal() {
            document.getElementById('mappingPreviewModal').style.display = 'none';
        }

        // Plainly Validation Functions
        async function validatePlainly() {
            const validateBtn = document.getElementById('validatePlainlyBtn');
            const skipBtn = document.getElementById('skipValidationBtn');

            validateBtn.disabled = true;
            skipBtn.disabled = true;
            validateBtn.textContent = 'üîç Validating...';
            showStatus('validationStatus', 'Validating for Plainly compatibility...', 'info');

            try {
                const response = await fetch('/validate-plainly', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                });

                const result = await response.json();

                if (result.success) {
                    showStatus('validationStatus', result.message, 'success');
                    displayValidationReport(result.validation);
                } else {
                    showStatus('validationStatus', result.message, 'error');
                    validateBtn.disabled = false;
                    skipBtn.disabled = false;
                    validateBtn.textContent = 'üîç Validate for Plainly';
                }
            } catch (error) {
                showStatus('validationStatus', `Validation error: ${error.message}`, 'error');
                validateBtn.disabled = false;
                skipBtn.disabled = false;
                validateBtn.textContent = 'üîç Validate for Plainly';
            }
        }

        function displayValidationReport(validation) {
            const reportEl = document.getElementById('validationReport');
            const scoreNumberEl = document.getElementById('scoreNumber');
            const scoreGradeEl = document.getElementById('scoreGrade');
            const scoreMessageEl = document.getElementById('scoreMessage');
            const summaryEl = document.getElementById('validationSummary');

            // Show report
            reportEl.style.display = 'block';

            // Display score
            scoreNumberEl.textContent = Math.round(validation.score);
            scoreGradeEl.textContent = validation.grade;
            scoreMessageEl.textContent = validation.status_message;

            // Color code based on grade
            const scoreCard = document.getElementById('validationScoreCard');
            scoreCard.className = 'validation-score-card';
            if (validation.grade === 'A' || validation.grade === 'B') {
                scoreCard.classList.add('grade-good');
            } else if (validation.grade === 'C' || validation.grade === 'D') {
                scoreCard.classList.add('grade-warning');
            } else {
                scoreCard.classList.add('grade-critical');
            }

            // Display summary
            const summary = validation.summary;
            summaryEl.innerHTML = `
                <div class="summary-stat">
                    <span class="stat-label">Total Issues:</span>
                    <span class="stat-value">${summary.total_issues}</span>
                </div>
                <div class="summary-stat critical">
                    <span class="stat-label">Critical:</span>
                    <span class="stat-value">${summary.critical}</span>
                </div>
                <div class="summary-stat warning">
                    <span class="stat-label">Warnings:</span>
                    <span class="stat-value">${summary.warnings}</span>
                </div>
                <div class="summary-stat info">
                    <span class="stat-label">Recommendations:</span>
                    <span class="stat-value">${summary.info}</span>
                </div>
            `;

            // Check for fixable issues
            const fixableIssues = getFixableIssues(validation.issues);
            const autoFixSection = document.getElementById('autoFixSection');
            const autoFixCount = document.getElementById('autoFixCount');

            if (fixableIssues.length > 0) {
                autoFixSection.style.display = 'block';
                autoFixCount.textContent = `${fixableIssues.length} issue${fixableIssues.length > 1 ? 's' : ''} can be automatically fixed`;
            } else {
                autoFixSection.style.display = 'none';
            }

            // Display issues by severity
            displayIssuesByCategory(validation.issues);

            // Show/hide deploy button based on readiness
            const deployBtn = document.getElementById('deployToPlainlyBtn');
            if (validation.plainly_ready) {
                deployBtn.style.display = 'inline-block';
            } else {
                deployBtn.style.display = 'none';
            }
        }

        function getFixableIssues(issues) {
            // Issues that can be auto-fixed:
            // - category: 'characters' (non-English characters)
            // - category: 'naming' with 'prefix' in message (missing prefixes)
            // - category: 'composition' with 'No render composition' message
            return issues.filter(issue => {
                if (issue.category === 'characters') return true;
                if (issue.category === 'naming' && issue.message.toLowerCase().includes('prefix')) return true;
                if (issue.category === 'composition' && issue.message.includes('No render composition')) return true;
                return false;
            });
        }

        function displayIssuesByCategory(issues) {
            const criticalList = document.getElementById('criticalIssuesList');
            const warningList = document.getElementById('warningIssuesList');
            const infoList = document.getElementById('infoIssuesList');

            const criticalSection = document.getElementById('criticalIssues');
            const warningSection = document.getElementById('warningIssues');
            const infoSection = document.getElementById('infoIssues');

            // Filter issues by severity
            const criticalIssues = issues.filter(i => i.severity === 'critical');
            const warningIssues = issues.filter(i => i.severity === 'warning');
            const infoIssues = issues.filter(i => i.severity === 'info');

            // Display critical issues
            if (criticalIssues.length > 0) {
                criticalSection.style.display = 'block';
                criticalList.innerHTML = criticalIssues.map(issue => `
                    <div class="issue-item critical">
                        <div class="issue-title">${issue.message}</div>
                        <div class="issue-details">${issue.details}</div>
                        <div class="issue-fix">üí° Fix: ${issue.fix_suggestion}</div>
                        ${issue.layer_name ? `<div class="issue-location">Layer: ${issue.layer_name}</div>` : ''}
                        ${issue.composition_name ? `<div class="issue-location">Comp: ${issue.composition_name}</div>` : ''}
                    </div>
                `).join('');
            } else {
                criticalSection.style.display = 'none';
            }

            // Display warnings
            if (warningIssues.length > 0) {
                warningSection.style.display = 'block';
                warningList.innerHTML = warningIssues.map(issue => `
                    <div class="issue-item warning">
                        <div class="issue-title">${issue.message}</div>
                        <div class="issue-details">${issue.details}</div>
                        <div class="issue-fix">üí° Fix: ${issue.fix_suggestion}</div>
                        ${issue.layer_name ? `<div class="issue-location">Layer: ${issue.layer_name}</div>` : ''}
                        ${issue.composition_name ? `<div class="issue-location">Comp: ${issue.composition_name}</div>` : ''}
                    </div>
                `).join('');
            } else {
                warningSection.style.display = 'none';
            }

            // Display info/recommendations
            if (infoIssues.length > 0) {
                infoSection.style.display = 'block';
                infoList.innerHTML = infoIssues.map(issue => `
                    <div class="issue-item info">
                        <div class="issue-title">${issue.message}</div>
                        <div class="issue-details">${issue.details}</div>
                        <div class="issue-fix">üí° Suggestion: ${issue.fix_suggestion}</div>
                        ${issue.layer_name ? `<div class="issue-location">Layer: ${issue.layer_name}</div>` : ''}
                        ${issue.composition_name ? `<div class="issue-location">Comp: ${issue.composition_name}</div>` : ''}
                    </div>
                `).join('');
            } else {
                infoSection.style.display = 'none';
            }
        }

        async function applyAutoFixes() {
            const fixAllBtn = document.getElementById('fixAllBtn');
            const fixProgress = document.getElementById('fixProgress');

            fixAllBtn.disabled = true;
            fixAllBtn.textContent = 'üîß Applying Fixes...';
            fixProgress.style.display = 'block';
            fixProgress.innerHTML = '<div class="status-message info">üîß Applying automatic fixes...</div>';

            try {
                const response = await fetch('/apply-plainly-fixes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                });

                const result = await response.json();

                if (result.success) {
                    // Show success message with changes
                    let changesList = '<div class="fix-results">';
                    changesList += `<div class="success-banner">‚úÖ Fixed ${result.fix_result.fixed_count} issues!</div>`;
                    changesList += '<ul class="changes-list">';

                    for (const change of result.fix_result.changes) {
                        changesList += `<li class="change-item">`;
                        changesList += `<strong>${change.type.replace(/_/g, ' ')}:</strong> `;
                        changesList += `<span class="old-value">${change.old_name}</span> `;
                        changesList += `‚Üí <span class="new-value">${change.new_name}</span>`;
                        changesList += `</li>`;
                    }

                    changesList += '</ul></div>';
                    fixProgress.innerHTML = changesList;

                    // Update validation report with new results
                    if (result.validation) {
                        displayValidationReport(result.validation);
                    }

                    // Re-enable button with new text
                    fixAllBtn.textContent = '‚úÖ Fixes Applied!';
                    fixAllBtn.disabled = true;

                    // Scroll to show updated results
                    setTimeout(() => {
                        document.getElementById('validationScoreCard').scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }, 500);
                } else {
                    fixProgress.innerHTML = `<div class="status-message error">‚ùå ${result.message}</div>`;
                    fixAllBtn.disabled = false;
                    fixAllBtn.textContent = 'üîß Fix All Issues';
                }
            } catch (error) {
                fixProgress.innerHTML = `<div class="status-message error">‚ùå Error: ${error.message}</div>`;
                fixAllBtn.disabled = false;
                fixAllBtn.textContent = 'üîß Fix All Issues';
            }
        }

        function skipValidation() {
            console.log('Validation skipped by user');
            showStatus('validationStatus', 'Validation skipped. Proceeding without Plainly validation.', 'info');
            // Could add logic to proceed to next step if needed
        }

        function downloadValidationReport() {
            // Create a text report from the current validation data
            const reportText = generateReportText();
            const blob = new Blob([reportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `plainly-validation-report-${Date.now()}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function generateReportText() {
            const scoreNumber = document.getElementById('scoreNumber').textContent;
            const scoreGrade = document.getElementById('scoreGrade').textContent;
            const scoreMessage = document.getElementById('scoreMessage').textContent;

            let report = `PLAINLY VALIDATION REPORT\n`;
            report += `Generated: ${new Date().toLocaleString()}\n`;
            report += `${'='.repeat(70)}\n\n`;
            report += `OVERALL SCORE: ${scoreNumber}/100 (Grade: ${scoreGrade})\n`;
            report += `Status: ${scoreMessage}\n\n`;

            // Add issues
            const criticalIssues = document.querySelectorAll('.critical-issues .issue-item');
            const warningIssues = document.querySelectorAll('.warning-issues .issue-item');
            const infoIssues = document.querySelectorAll('.info-issues .issue-item');

            if (criticalIssues.length > 0) {
                report += `\nCRITICAL ISSUES (${criticalIssues.length}):\n${'='.repeat(70)}\n`;
                criticalIssues.forEach((item, i) => {
                    report += `\n${i + 1}. ${item.querySelector('.issue-title').textContent}\n`;
                    report += `   ${item.querySelector('.issue-details').textContent}\n`;
                    report += `   ${item.querySelector('.issue-fix').textContent}\n`;
                });
            }

            if (warningIssues.length > 0) {
                report += `\n\nWARNINGS (${warningIssues.length}):\n${'='.repeat(70)}\n`;
                warningIssues.forEach((item, i) => {
                    report += `\n${i + 1}. ${item.querySelector('.issue-title').textContent}\n`;
                    report += `   ${item.querySelector('.issue-details').textContent}\n`;
                    report += `   ${item.querySelector('.issue-fix').textContent}\n`;
                });
            }

            if (infoIssues.length > 0) {
                report += `\n\nRECOMMENDATIONS (${infoIssues.length}):\n${'='.repeat(70)}\n`;
                infoIssues.forEach((item, i) => {
                    report += `\n${i + 1}. ${item.querySelector('.issue-title').textContent}\n`;
                    report += `   ${item.querySelector('.issue-details').textContent}\n`;
                    report += `   ${item.querySelector('.issue-fix').textContent}\n`;
                });
            }

            report += `\n${'='.repeat(70)}\n`;
            report += `END OF REPORT\n`;

            return report;
        }

        // ========================================================================
        // PREVIEW & SIGN-OFF WORKFLOW
        // ========================================================================

        // Preview & Sign-off Workflow
        const workflowSettings = {
            validateBeforePreview: {{ 'true' if VALIDATE_BEFORE_PREVIEW else 'false' }},
            requireSignoff: {{ 'true' if REQUIRE_SIGNOFF_FOR_RENDER else 'false' }}
        };

        // Event listeners
        document.getElementById('generatePreviewsBtn')?.addEventListener('click', generatePreviews);
        document.getElementById('regeneratePsdBtn')?.addEventListener('click', generatePreviews);
        document.getElementById('regenerateAeBtn')?.addEventListener('click', generatePreviews);
        document.getElementById('approveBtn')?.addEventListener('click', approveSignoff);
        document.getElementById('signoffCheckbox')?.addEventListener('change', updateApproveButton);

        async function generatePreviews() {
            const btn = document.getElementById('generatePreviewsBtn');
            const status = document.getElementById('previewGenStatus');

            btn.disabled = true;
            btn.textContent = 'üé¨ Generating Previews...';
            status.innerHTML = '<div class="status-message info">Generating side-by-side previews...</div>';

            try {
                const response = await fetch('/previews/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                });

                const result = await response.json();

                if (result.success) {
                    status.innerHTML = '<div class="status-message success">‚úÖ Previews generated!</div>';

                    // Show preview container
                    const container = document.getElementById('previewContainer');
                    container.style.display = 'grid';

                    // Load images/videos
                    document.getElementById('psdPreviewImg').src = result.preview.psd_png_url;
                    document.getElementById('aePreviewVideo').src = result.preview.ae_mp4_url;

                    // Show sign-off card
                    document.getElementById('signoffCard').style.display = 'block';

                    // Update validation strip if validation exists
                    updateValidationStrip();

                    btn.textContent = '‚úÖ Previews Ready';
                } else {
                    status.innerHTML = `<div class="status-message error">‚ùå ${result.error}</div>`;
                    btn.disabled = false;
                    btn.textContent = 'üé¨ Generate Side-by-Side Previews';
                }
            } catch (error) {
                status.innerHTML = `<div class="status-message error">‚ùå Error: ${error.message}</div>`;
                btn.disabled = false;
                btn.textContent = 'üé¨ Generate Side-by-Side Previews';
            }
        }

        async function approveSignoff() {
            const btn = document.getElementById('approveBtn');
            const status = document.getElementById('signoffStatus');
            const notes = document.getElementById('signoffNotes').value;

            btn.disabled = true;
            btn.textContent = '‚úÖ Approving...';
            status.innerHTML = '<div class="status-message info">Processing sign-off...</div>';

            try {
                const response = await fetch('/signoff/approve', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        notes: notes,
                        user: 'current_user'  // Replace with actual user from auth
                    })
                });

                const result = await response.json();

                if (result.success) {
                    status.innerHTML = '<div class="status-message success">‚úÖ Approved! Final render started.</div>';
                    btn.textContent = '‚úÖ Approved';
                    document.getElementById('signoffCheckbox').disabled = true;
                    document.getElementById('signoffNotes').disabled = true;
                } else {
                    status.innerHTML = `<div class="status-message error">‚ùå ${result.error}</div>`;
                    btn.disabled = false;
                    btn.textContent = '‚úÖ Approve & Start Final Render';
                }
            } catch (error) {
                status.innerHTML = `<div class="status-message error">‚ùå Error: ${error.message}</div>`;
                btn.disabled = false;
                btn.textContent = '‚úÖ Approve & Start Final Render';
            }
        }

        function updateApproveButton() {
            const approve = document.getElementById('approveBtn');
            const checkbox = document.getElementById('signoffCheckbox');

            // Enable only if checked
            approve.disabled = !checkbox.checked;
        }

        function updateValidationStrip() {
            const strip = document.getElementById('validationStrip');
            const badge = document.getElementById('validationBadge');

            // Check if validation report is visible
            const validationReport = document.getElementById('validationReport');
            if (validationReport && validationReport.style.display !== 'none') {
                strip.style.display = 'flex';
                const grade = document.getElementById('scoreGrade').textContent;
                const score = document.getElementById('scoreNumber').textContent;
                badge.textContent = `${grade} (${score}%)`;
                badge.className = grade === 'A' || grade === 'B' ? 'badge badge-ok' : 'badge badge-warn';
            }
        }
    </script>

    <!-- Mapping Preview Modal -->
    <div id="mappingPreviewModal" class="preview-modal">
        <div class="preview-modal-content">
            <div class="preview-modal-header">
                <h2>Mapping Preview</h2>
                <button class="preview-modal-close" onclick="closeMappingPreviewModal()">&times;</button>
            </div>
            <div class="preview-modal-body">
                <div class="preview-mapping-info">
                    <div class="preview-mapping-source">
                        <strong>PSD Layer:</strong>
                        <span id="modalPsdLayer"></span>
                    </div>
                    <div class="preview-mapping-arrow">‚Üí</div>
                    <div class="preview-mapping-target">
                        <strong>AEPX Placeholder:</strong>
                        <span id="modalAepxPlaceholder"></span>
                    </div>
                </div>
                <div class="preview-composite-container">
                    <img id="modalCompositeImage" alt="Mapping preview" class="preview-composite-image">
                </div>
                <div class="preview-legend">
                    <div class="legend-item">
                        <span class="legend-color" style="background: #667eea;"></span>
                        <span>PSD Layer</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #10b981;"></span>
                        <span>Overlay Result</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #f59e0b;"></span>
                        <span>AEPX Placeholder</span>
                    </div>
                </div>
            </div>
            <div class="preview-modal-footer">
                <button class="btn btn-secondary" onclick="closeMappingPreviewModal()">Close</button>
            </div>
        </div>
    </div>

</body>
</html>
